#!/usr/bin/env python

###
# Copyright (c) 2005, Ali Afshar
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice,
#     this list of conditions, and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions, and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#   * Neither the name of the author of this software nor the name of
#     contributors to this software may be used to endorse or promote products
#     derived from this software without specific prior written consent.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
###

import os
import shutil

import supybot

# We need to do this before we import conf.
if not os.path.exists('doc-conf'):
    os.mkdir('doc-conf')

registryFilename = os.path.join('doc-conf', 'doc.conf')
fd = file(registryFilename, 'w')
fd.write("""
supybot.directories.data: doc-data
supybot.directories.conf: doc-conf
supybot.directories.log: doc-logs
supybot.log.stdout: False
supybot.log.level: DEBUG
supybot.log.format: %(levelname)s %(message)s
supybot.log.plugins.individualLogfiles: False
supybot.databases: sqlite anydbm cdb flat pickle
""")
fd.close()

import supybot.registry as registry
registry.open(registryFilename)

import supybot.log as log
import supybot.conf as conf
conf.supybot.flush.setValue(False)

import cgi
import sys
import textwrap

import supybot.utils as utils
import supybot.world as world
import supybot.plugin as plugin
import supybot.registry as registry

world.documenting = True

class PluginDoc(object):
    def __init__(self, mod, escape):
        self.mod = mod
        self.inst = self.mod.Class(None)
        self.name = self.mod.Class.__name__
        self.escape = escape
        self.lines = []

    def appendLine(self, line, indent=0, escaped=False):
        line = line.strip()
        if escaped and self.escape:
            line = cgi.escape(line)
        if self.escape:
            sections = line.split("'")
            slen = len(sections) - 1
            # Don't want to escape characters inside of single-quoted strings
            if slen and slen % 2 == 0:
                for i in xrange(0, 2, slen):
                    sections[i] = sections[i].replace('[', '&#91;')
                    sections[i] = sections[i].replace(']', '&#93;')
            line = "'".join(sections)
        indent = '  ' * indent
        lines = textwrap.wrap(line, 79,
                              initial_indent=indent,
                              subsequent_indent=indent)
        self.lines.extend(lines)
        self.lines.append('')

    def renderSTX(self):
        self.appendLine('Documentation for the %s plugin for '
                        'Supybot' % self.name)
        self.appendLine('Purpose', 1)
        pdoc = getattr(self.mod, '__doc__',
                       'My author didn\'t give me a purpose.')
        self.appendLine(pdoc, 2, escaped=True)
        cdoc = getattr(self.mod.Class, '__doc__', None)
        if cdoc is not None:
            self.appendLine('Usage', 1)
            self.appendLine(cdoc, 2, escaped=True)
        commands = self.inst.listCommands()
        if len(commands):
            self.appendLine('Commands', 1)
            for command in commands:
                log.debug('command: %s', command)
                if self.escape:
                    line = '* **%s** ' % command
                else:
                    line = '* %s ' % command
                command = command.split()
                doc = self.inst.getCommandHelp(command)
                if doc:
                    doc = doc.replace('\x02', '')
                    (args, help) = doc.split(')', 1)
                    args = args.split('(', 1)[1]
                    args = args[len(' '.join(command)):].strip()
                    help = help.split('--', 1)[1].strip()
                    self.appendLine(line + args, 2, escaped=True)
                    self.appendLine(help, 3, escaped=True)
                else:
                    self.appendLine('No help associated with this command', 3)
        # now the config
        self.appendLine('Configuration', 1)
        try:
            confs = conf.supybot.plugins.get(self.name)
        except registry.NonExistentRegistryEntry:
            log.info('No configuration for plugin %s', plugin)
            self.appendLine('No help configuration with this plugin', 2)
        else:
            self.genConfig(confs, 2)
        return '\n'.join(self.lines) + '\n'

    def genConfig(self, item, origindent):
        confVars = item.getValues(getChildren=False, fullNames=False)
        if not confVars:
            return
        for (c, v) in confVars:
            name = '* %s' % v._name
            self.appendLine(name, origindent)
            indent = origindent + 1
            try:
                default = str(v)
                if isinstance(v._default, basestring) or v._default is None:
                    default = utils.str.dqrepr(default)
                help = v.help()
                channelValue = v.channelValue
            except registry.NonExistentRegistryEntry:
                pass
            else:
                if channelValue:
                    cv = 'is'
                else:
                    cv = 'is not'
                if self.escape:
                    default = '**%s**' % default
                self.appendLine('This config variable defaults to %s and %s '
                                'channel specific.' % (default, cv), indent)
                if self.escape:
                    help = cgi.escape(help)
                self.appendLine(help, indent)
            self.genConfig(v, indent)

def genDoc(m, escape):
    Plugin = PluginDoc(m, escape)
    print 'Generating documentation for %s...' % Plugin.name
    try:
        fd = file('%s.stx' % Plugin.name, 'w')
    except EnvironmentError, e:
        sys.stderr.write('Unable to open %s.stx for writing.' % Plugin.name)
        sys.exit(-1)
    try:
        fd.write(Plugin.renderSTX())
    finally:
        fd.close()

if __name__ == '__main__':
    import glob
    import os.path
    import optparse
    import supybot.plugin as plugin

    parser = optparse.OptionParser(usage='Usage: %prog [options] [plugins]',
                                   version='Supybot %s' % conf.version)
    parser.add_option('-c', '--clean', action='store_true', default=False,
                      dest='clean', help='Cleans the various data/conf/logs '
                      'directories after generating the docs.')
    parser.add_option('--no-escape',
                      action='store_false', default=True, dest='escape',
                      help='Disables escaping of html entities e.g., < as '
                      '&lt;. This is useful for making offline documentation.')
    parser.add_option('--plugins-dir',
                      action='append', dest='pluginsDirs', default=[],
                      help='Looks in in the given directory for plugins and '
                      'generates documentation for all of them.')
    (options, args) = parser.parse_args()

    # This must go before checking for args, of course.
    for pluginDir in options.pluginsDirs:
        for name in glob.glob(os.path.join(pluginDir, '*')):
            #print '***', name
            if os.path.isdir(name):
                args.append(name)

    if not args:
        parser.print_help()
        sys.exit(-1)

    args = [s.rstrip('\\/') for s in args]
    pluginDirs = set([os.path.dirname(s) or '.' for s in args])
    conf.supybot.directories.plugins.setValue(list(pluginDirs))
    pluginNames = set([os.path.basename(s) for s in args])
    plugins = set([])
    for pluginName in pluginNames:
        if pluginName.endswith('.py'):
            pluginName = pluginName[:-3]
        try:
            pluginModule = plugin.loadPluginModule(pluginName)
        except ImportError, e:
            sys.stderr.write('Failed to load plugin %s: %s\n' % (pluginName,e))
            sys.stderr.write('(pluginDirs: %s)' %
                             conf.supybot.directories.plugins())
            sys.exit(-1)
        plugins.add(pluginModule)

    for Plugin in plugins:
        genDoc(Plugin, options.escape)

    if options.clean:
        shutil.rmtree(conf.supybot.directories.log())
        shutil.rmtree(conf.supybot.directories.conf())
        shutil.rmtree(conf.supybot.directories.data())

# vim:set shiftwidth=4 tabstop=4 expandtab textwidth=78:
